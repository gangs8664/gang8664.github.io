소프트웨어 공학 개요
===

1. 소프트웨어 공학의 정의와 목적
2. 소프트웨어의 특징성과 복잡성
3. 소프트웨어 개발의 중요성과 도전 과제
4. 소프트웨어 공학의 발전 과정

소프트웨어 정의
===
* 프로그램 : 프로그래밍 언어로 작성된 원시 코드(source code)
* 소프트웨어 : 프로그램 + 개발 과정에서 생성된 모든 산출물
  * 일반 사용자의 입장에서 소프트웨어는 **컴퓨터를 작동하기 위한 프로그램들의 집합**이다.

소프트웨어 공학의 정의와 목적
===
소프트웨어 공학
---
 소프트웨어를 개발하기 위하여 요구사항 분석부터 유지보수까지, 개발과정에서부터 관리까지 전 과정을 체계적으로 관리하는 방법론.

소프트웨어 공학의 목표
---
 개발 대상의 명확화, 체계화, 수명 주기 지원을 통해 사용자의 요구사항을 충족시키는 품질 좋은 소프트웨어 개발.

소프트웨어 공학의 목적
---
* 고객, 개발자, 관리자가 의견을 조율하여 요구사항을 정확히 파악
* 개발 비용 산정과 개발 계획을 수립하여 완성품에 대한 초석을 잡음
* 일정, 예산, 인원에 대한 정확한 분배에 도움
* 개발자와 관리자가 소프트웨어 개발에 필요한 표준 용어를 사용
* 소프트웨어 개발 과정에 대해 명확히 구분
* 개발 일정 지연이나 비용 추가에 대한 부분을 쉽게 파악
* 모든 단계를 문서화하여 프로젝트 관리


소프트웨어의 특징과 복잡성
===
<h2>소프트웨어의 특징 </h2>

* 제조 vs 개발
  * 제조 : 정해진 절차에 따라 결과물을 생산한다. : 개인 능력간 별 차이가 적다.   
  * 개발 : 요구 조건을 기반으로 결과물을 생산한다. : 개인 능력간의 차이가 크다.
  
* 하드웨어 vs 소프트웨어
  * 하드웨어 : 오래 사용하면 부품이 닳고 기능도 떨어진다.
  * 소프트웨어 : 오래 사용한다고 닳지 않으며 시간이 지나도 고장의 빈도가 높지 않다.

* 소프트웨어는 제조가 아닌 개발이다. 개인 능력에 따라 차이가 크다. 또한 소모가 아닌 품질 저하다.

* 그림 1. 하드웨어 실패 곡선
![Alt text](./image2.png)
  * 초기 고장률이 매우 높지만, 오류를 해결하면 큰 문제 없이 오래 지속됨을 알 수 있다. 이후 장기간 사용시 주변 환경의 문제로 고장률이 높게 치솟는다.

* 그림 2. 실제 소프트웨어의 실패 곡선
![Alt text](./image3.png)
  * 소프트웨어의 특징 중 하나로 사용 시작 단계부터 사용자의 요구가 계속 발생한다. 또한 설치 환경이 달라질 수 있다. 새로운 기능이 추가되는 등 변경 사항이 발생한다. 이 때 변경으로 인한 부작용으로 고장률이 급격히 증가할 수 있고 반복적인 변경으로 인해 고장률도 반복적으로 증가한다.   
그림 출처 : 한국통신학회지 제 8권 제 5호

소프트웨어 특성
---
* 기본적으로 9가지의 특성을 가진다.
* 상품성
  * 개발이 완료된 소프트웨어는 상품화된다.
* 견고성
  * 소프트웨어의 부분적 수정으로 소프트웨어 전체에 영향을 미칠 수 있으므로 수정이나 변경이 용이하지 않는다.
* 복잡성
  * 개발의 과정은 복잡하고 까다롭다. 따라서 산출물에 대한 표준화가 필요하다.
* 순응성
  * 사용자의 요구사항이나 환경 변화에 맞춰 빠르게 변경할 수 있다.
* 비가시성
  * 개발이 완료될 때까지는 소프트웨어의 결과물을 알 수 없으며 완성되기 전까지 코드에 의존한다.
* 비마모성
  * 소프트웨어는 마모되거나 없어지지 않는다.
* 비제조성
  * 하드웨어는 제조하지만 소프트웨어는 논리적인 사고를 가지고 개발한다.
* 비과학성
  * 소프트웨어 개발을 위해서 시간과 인력 그리고 노력이 필요하다. 또한 절차 중심이다.
* 복제성
  * 소프트웨어는 무한하게 복제가 가능하다.
  * 하지만 저작권의 문제는 고려할 필요가 있다.

소프트웨어 개발의 중요성과 도전 과제
===
* 정보기술의 발전이 21세기를 지식과 정보 혁명의 시대로 탈바꿈시켰다.
* 정보기술이 발전할수록 소프트웨어의 중요성은 점점 더 강조된다.
* 소프트웨어는 정보화 시대에서 사회의 많은 분야를 움직이는 원동력이다.
  * 사업체의 의사결정을 지원하는 엔진이다.
  * 현대적 과학 탐구와 공학적 문제 해결을 지원하는 기본 도구다.
  * 교통, 의료, 원거리 통신, 군사, 산업체, 연예계, 사무용품 등에 사용되는 모든 종류의 컴퓨터 시스템에 내장되어 있다.
* 소프트웨어는 우리 생활의 거의 모든 면에 영향을 주고 있다. 사회와 문화에 주는 영향력은 점점 커지고 있다.
* 소프트웨어의 중요성이 증가함에 따라 소프트웨어 유관 단체들은 계속해서 적은 비용으로 더 쉽고 더 빠르게 고품질의 컴퓨터 프로그램을 만들기 위한 기술 개발에 노력하고 있다.

* 소프트웨어 개발에서의 도전 과제는 소프트웨어 유지보수, 보안 및 보증과 사용자의 증가하는 요구를 효율적으로 수용하기 위한 확장성에 중점을 두고 있다.
    * https://hitek.com.vn/ko/blog-ko/the-software-development/#%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%EA%B0%9C%EB%B0%9C%EC%9D%98_%EB%AF%B8%EB%9E%98
* 소프트웨어 개발의 미래는 지속적인 소프트웨어 혁신, 소프트웨어 기술의 발전, 그리고 포괄적인 소프트웨어 솔루션의 진보에 의해 상당한 변화를 겪을 것으로 예상된다.

소프트웨어 공학의 발전 과정
===
1. 초기 소프트웨어 개발 (1950~1960년대)
* 주요 배경:
  * 초기에는 소프트웨어 개발이 하드웨어 설계에 종속적이었고, 주로 과학 계산이나 군사 목적에 사용되었다.
  * 1950년대: 최초의 프로그래밍 언어인 Fortran과 COBOL 개발.
  * 1960년대: 운영 체제(OS) 등장 및 모듈화 개념 도입.
* 특징:
  * 소프트웨어 개발이 공학적 접근이 아닌 실험적 과정으로 수행됨.
  * 시스템의 크기와 복잡성 증가로 유지보수 문제 발생.

2. 소프트웨어 위기와 공학적 접근 (1970년대)   
* 주요 배경:   
  * 소프트웨어 위기가 대두됨: 프로젝트 실패, 비용 초과, 일정 지연 등. 
  * 데이크스트라와 같은 학자들이 구조적 프로그래밍의 중요성을 강조.   
* 변화와 발전:
  * 소프트웨어 공학이라는 개념이 본격적으로 등장.
  * 소프트웨어 개발 과정에 체계적 방법론(Waterfall 모델) 도입.

3. 객체 지향과 품질 관리의 부상 (1980년대)
* 주요 배경:
  * 소프트웨어 규모와 복잡성이 급증하면서 재사용성과 유지보수성의 필요성 증가.
  * 객체 지향 개념과 관련 언어(C++, Smalltalk 등)가 주목받음.
* 변화와 발전:
  * 품질 관리(QA)와 테스트 방법론 발전.
  * 사용자 인터페이스(UI) 설계 중요성 부각.

4. 인터넷과 글로벌 협업 시대 (1990년대)
* 주요 배경:
  * 인터넷과 웹 기술의 대중화.
  * 오픈 소스 운동 확산(Linux, Apache 등).

* 변화와 발전: 
  * 소프트웨어 개발이 팀 단위로 진행되며, 글로벌 협업 환경 형성.
  * 분산 시스템과 클라이언트-서버 모델의 부상.

5. 애자일과 DevOps의 등장 (2000년대 이후)
* 주요 배경:

  * 기존의 전통적 개발 모델이 빠르게 변화하는 요구사항에 대응하기 어려움.
  * 애자일 방법론과 DevOps의 등장으로 개발과 운영의 통합이 강조됨.
* 변화와 발전:

  * 지속적 통합(CI), 지속적 배포(CD) 개념 도입.
  * 소프트웨어 공학에서 **사용자 경험(UX)**의 중요성 확대.
6. 현재와 미래 전망 (2020년대~)
* 주요 배경:

  * 인공지능(AI), 머신러닝, 클라우드 컴퓨팅이 주도하는 기술 혁신.
  * 소프트웨어의 중요성이 모든 산업 분야로 확장됨.
* 변화와 발전:
  * DevOps와 클라우드 네이티브 개발 방식의 확산.
  * 지속 가능성(Sustainability)과 보안(Security)이 주요 과제로 부상.

소프트웨어 개발 생명주기(SDLC)
===
1. SDLC 모델의 개념
2. 전통적 SDLC 모델
   1. 폭포수 모델
   2. V-모델
3. 현대적 SDLC 모델
   1. 애자일(Agile)
   2. 스크럼(Scrum)
   3. 칸반(Kanban)
4. DevOps와 CI/CD

SDLC 모델의 개념
---
소프트웨어 개발 생명주기 (Software Development Life Cycle) :
* 소프트웨어를 만들기 위해 계획 단계부터 유지보수 단계에 이르기까지 일어나는 일련의 과정이다. 
* SDLC의 목표는 사전 계획을 통해 프로젝트 위험을 최소화함으로써 소프트웨어가 생산 중일 때 그리고 그 이후에도 고객의 기대치를 충족하도록 하는 것이다.
  * https://aws.amazon.com/ko/what-is/sdlc/
![Alt text](./image4.png)
출처 : https://melsatar.blog/2012/03/15/software-development-life-cycle-models-and-methodologies/

* 소프트웨어 개발 단계
  * 계획(Plan)
    * 개발할 소프트웨어를 정의하고 소프트웨어 개발의 필요성에 대한 타당성을 검증한다.
    * 개발에 필요한 비용 및 인력을 산정하고 일정 계획과 위험 분석 및 대책을 수립한다.
  * 요구사항 분석(Requirement Analysis)
    * 개발할 소프트웨어의 기능과 제약조건, 목표 등을 사용자와 함께 정의한다.
  * 설계(Design)
    * 소프트웨어 구조(아키텍처)를 논리적으로 결정한다.
    * 시스템 구조 설계 : 시스템을 구성하는 프로그램 간 관계와 구조를 설계한다.
    * 프로그램 설계 : 프로그램 내 각 모듈에서의 처리 절차나 알고리즘을 설계한다.
    * UI(User Interface) 설계 : 사용자 인터페이스를 설계한다.
  * 구현(Implementation)
    * 논리적으로 결정된 구조를 프로그래밍 언어를 통해 실제 프로그램을 작성한다.
  * 테스트(Test)
    * 개발한 소프트웨어가 요구사항을 만족하는지, 결과가 정확한지를 평가한다.
    * 단위 테스트(Unit test)
      * 소프트웨어 최소 구성요소인 모듈에 대한 평가이다.
    * 통합 테스트(Integration test)
      * 단위 테스트를 통과한 모듈을 점진적으로 연결하여 확장해 나가며 전체 소프트웨어를 완성한다.
      * 통합적으로 소프트웨어를 평가한다.
    * 인수 테스트(Acceptation test)
      * 완성된 소프트웨어를 인수하기 위해 실제 데이터를 사용하여 최종 평가한다.
  * 유지보수(Maintenance)
    * 소프트웨어가 인수/납품/배포된 후 일어나는 모든 활동을 말한다.
    * 소프트웨어 개발 생명주기 중 가장 긴 기간을 차지한다.
      * 수정 유지보수(corrective maintenance) : 발견된 오류의 원인을 찾아 수정하여 문제를 해결하는 것.
      * 적응 유지보수(adaptive maintenence) : 외부 환경 변화에 적응하기 위한 수정을 말한다.
      * 완전 유지보수(perfective maintenance) : 기능이나 성능 향상을 위해 수정하는 것을 말한다.
      * 예방 유지보수(preventive maintenance) : 이해성과 유지보수성의 개선을 위한 수정을 말한다.

전통적 SDLC모델
---
<h3>폭포수 모델(Waterfall Model)</h3>
  
* 소프트웨어 공학의 기본이다.
* 초기에 개발된 전통적인 모델이다.
  * 고전적 생명 주기 (classic life cycle)라고도 한다.
*  계획, 분석, 설계, 구현, 테스트, 유지보수의 단계를 순차적으로 진행한다.
   *  개발 계획서, 요구분석 명세서, 설계서 등 단계 별 산출물을 작성한다.
   *  산출물을 기반으로 이상 유무를 판단하고 다음 단계로 진행한다(top-down 방식)
* 표준 프로세스를 정하여 소프트웨어를 순차적으로 개발한다.
  * 공장 생산 라인의 작업 프로세스와 유사하다.

* 폭포수 모델의 장점 :
  * 정형화된 절차를 통해 관리가 용이하다.
  * 체계적으로 문서화할 수 있다.
  * 요구사항의 변화가 적은 프로젝트에 적합하다.
* 폭포수 모델의 단점 : 
  * 각 단계는 앞 단계가 완료되어야 수행할 수 있다.
  * 각 단계마다 작성된 결과가 완벽해야 다음 단계에서 오류가 발생되지 않는다.
  * 사용자가 중간에 가시적인 결과를 볼 수 없다.
    * 사용자에 의한 결과물 검증까지 오랜 시간이 필요하다.
    * 결과물에 대한 수정을 요구할 경우에도 오랜 시간이 필요하다.

![Alt text](./image5.png)
(출처:https://onecoin-life.com/24#google_vignette)

<h3>V-모델</h3>

* 폭포수 모델을 변형한 것으로 테스트 단계를 추가 확장한 것이다.
* 테스트 단계가 분석 및 설계와 어떻게 관련되어 있는지를 나타낸다.
* 폭포수 모델이 *산출물 중심* 이라면, V 모델은 각 단게의 검증에 초점을 둔다.
  * 이것이 결과물의 오류를 줄일 수 있는 것이다.
* 단계별 테스트 유형
  * 단위 테스트 : 구현 단계에서 프로그램 개발자에 의해 수행된다.
  * 통합 테스트 : 모듈을 결합하여 하나의 시스템으로 구성하여 테스트한다.
  * 시스템 테스트 : 통합 모듈에 대한 시스템적(비기능적) 테스트를 진행한다.
  * 인수 테스트 : 사용자의 만족 여부를 테스트하는 품질 테스트다. 

![Alt text](./image7.png)
(출처:https://onecoin-life.com/24#google_vignette)

* V 모델의 장점 :
  * 세세한 테스팅으로 오류를 줄인다.
  * 높은 신뢰도를 요구하는 프로젝트에 적합하다.
* V 모델의 단점 : 
  * 폭포수 모델과 같이 반복이 없기에 변경사항을 다루기 어렵다.

현대적 SDLC모델
---
<h3>애자일(Agile)</h3>

* 소프트웨어 개발에서 유연성과 협업을 강조한 현대적 접근 방식을 말한다.
  * 특징 :
    * 반복적이고 점진적인 개발 방식을 채택한다.
    * 고객 요구사항 변화에 신속히 대응할 수 있다.
    * 팀 간 협업과 지속적인 피드백을 중요시한다.
  * 주요 원칙 : 
    * 고객과의 지속적인 협업을 통해 요구사항을 반영한다.
    * 짧은 개발 주기(Sprint)를 통해 작고 배포 가능한 소프트웨어를 제공한다.
    * 개발팀과 비즈니스팀 간의 긴밀한 협력을 중시한다.
  * 장점 : 
    * 변화하는 요구사항에 빠르게 대응 가능하다.
    * 소프트웨어 품질 개선과 사용자 만족도가 증가한다.
  * 단점 : 
    * 명확한 계획이 없는 경우 프로젝트가 방황할 가능성이 있다.
    * 경험이 부족한 팀에서는 실행이 어려울 수 있다.

<h3>스크럼(Scrum)</h3>

* 애자일 방법론의 한 형태로, 소규모 팀에서 소프트웨어를 반복적이고 점진적으로 개발하는 방법론이다.
  * 특징 : 
    * 개발 주기(Sprint)는 일반적으로 2~4주로 설정한다.
    * 팀 구성원은 Product Owner, Scrum Master, Development Team으로 나뉜다.
    * 매일 짧은 시간 동안 진행되는 데일리 스크럼(Daily Scrum) 미팅이 있다.
  * 프로세스 : 
    * 백로그 관리: Product Backlog(전체 요구사항)와 Sprint Backlog(현재 Sprint에서 진행할 작업)를 정의한다.
    * 스프린트 계획: 목표 설정 및 우선순위 작업을 선택한다.
    * 스프린트 실행: Sprint 동안 개발 및 테스트 수행한다.
    * 리뷰 및 회고: 결과물 검토와 팀 개선 방안을 논의한다.
  * 장점 : 
    * 팀 내 높은 자율성과 책임 부여한다.
    * 빠른 피드백과 결과물 제공한다.
  * 단점 : 
    * 역할과 프로세스에 대한 명확한 이해가 필요하다. 
    * 큰 팀에서는 관리가 어려울 수 있다.

<h3>칸반(Kanban)</h3>

* 작업의 시각화와 흐름 관리를 통해 생산성을 높이는 방법론.
  * 특징 : 
    * 작업 단위를 보드에 시각적으로 표현한다.(주로 Trello, Jira와 같은 툴 사용).
    * 작업 흐름을 To Do, In Progress, Done으로 구분한다. 
    * WIP(Work In Progress) 제한으로 병목현상을 방지한다.
  * 프로세스 : 
    1. 작업 항목을 Kanban 보드에 추가한다.
    2. 작업 진행 상태를 실시간으로 업데이트한다. 
    3. 병목현상을 분석하고 프로세스를 개선한다.
  * 장점 : 
    * 작업 진행 상태를 쉽게 파악 가능하다. 
    * 팀의 작업 효율성과 집중력을 향상한다.
  * 단점 : 
    * 프로젝트 일정 계획이 명확하지 않을 수 있다.
    * 팀 간 협업보다는 개인 작업에 초점이 맞춰질 가능성이 있다.

DevOps와 CI/CD
---
<h3>DevOps</h3>

* 소프트웨어 개발(Development)과 운영(Operations)의 결합을 의미하며, 개발과 운영 간의 협업을 통해 소프트웨어를 더 빠르고 효율적으로 배포하고 관리하는 방법론이다.
* 목표 :
  * 개발과 운영 간의 장벽 제거한다.
  * 소프트웨어의 품질을 향상시키면서 배포 속도를 높인다.
  * 지속적인 통합과 배포(Continuous Integration and Delivery)를 통해 자동화를 실현한다.
* 특징 : 
  * 자동화: 소스 코드 빌드, 테스트, 배포 과정을 자동화한다. 
  * 협업: 개발자와 운영팀이 긴밀히 협력하여 문제를 조기에 해결한다. 
  * 모니터링: 소프트웨어 상태를 실시간으로 감시하고 성능을 개선한다.
* DevOps의 핵심 요소 :
  * 문화: 팀 간의 신뢰와 협력을 바탕으로 한다. 
  * 프로세스: 반복 가능한 워크플로를 통해 생산성을 극대화한다. 
  * 도구: CI/CD, 모니터링, 컨테이너 등의 도구를 활용하여 효율화한다.
* 장점 : 
  * 배포 속도 및 신뢰성 향상이 가능하다. 
  * 시스템 문제를 조기에 감지하고 해결 가능하다. 
  * 시장 변화에 빠르게 대응할 수 있다.
* 단점 : 
  * 초기 설정과 문화적 전환에 시간과 노력이 필요하다. 
  * 자동화 도구 학습 곡선이 존재한다.

<h3>CI/CD</h3><hr>

* CI/CD는 소프트웨어 개발 프로세스에서 지속적인 통합(CI)과 지속적인 배포(CD)를 통해 개발과 배포의 자동화를 실현하는 핵심 요소이다.
<h4>CI(Continuous Integration)</h4>

* 정의 : 개발자가 변경한 코드를 자주(main branch) 통합하며, 각 통합 시 자동으로 빌드와 테스트를 수행한다..
* 목적 : 
  * 코드 품질 보장한다.
  * 코드 통합 과정에서 발생할 수 있는 충돌을 빠르게 해결한다.
* 장점 :
  * 문제를 조기에 발견한다.
  * 개발 속도와 코드 신뢰성을 동시에 향상한다.
  
<h4>CD(Continuous Delivery / Continuous Deployment)</h4>

* 지속적인 배포(Continuous Delivery):
  * 통합 후 검증된 코드를 운영 환경으로 배포할 준비가 된 상태로 유지한다.
  * 운영 환경 배포는 수동으로 수행한다.

* 지속적인 배포(Continuous Deployment):
  * 검증된 코드를 자동으로 운영 환경에 배포한다.
  * 개발 이후 모든 과정이 완전 자동화한다.

* 목적 : 
  * 사용자에게 빠르고 빈번하게 소프트웨어를 제공하기 위함이다.
  * 배포 과정에서의 오류를 감소하는 것이다.

* CI/CD 프로세스 
  * 코드 변경 : 개발자가 코드에 변경 사항을 커밋한다.
  * 빌드 및 테스트(CI) : 자동화된 테스트를 통해 코드의 신뢰성을 검증한다.
  * 배포(CD) : 검증된 코드를 스테이징 또는 운영 환경에 자동 또는 수동으로 배포한다.

<h4>DevOps와 CI/CD의 관계</h4>

  * DevOps는 철학과 문화이며, CI/CD는 이를 실현하는 기술적 구현 방법이다.
  * CI/CD는 DevOps의 주요 구현 방식으로, DevOps의 목표인 효율적이고 빠른 소프트웨어 배포를 달성하는 데 핵심적인 역할을 한다.


요구사항 분석
===

1. 요구 사항의 정의와 중요성
2. 기능 요구 사항과 비기능 요구 사항
3. 요구 사항 수집 기법
   1. 인터뷰, 설문, 관찰, 워크숍
4. 요구 사항 명세서 작성
5. 요구 사항 검증 및 관리

<h3>요구 사항의 정의와 중요성</h3><hr>

* 요구 사항은 소프트웨어가 충족해야 할 조건을 설명한다. 소프트웨어가 어떤 기능과 동작을 해야 하는지를 정의한다. 
* 요구 사항 분석은 프로젝트 성공의 핵심이다. 이를 명확히 하지 않으면 프로젝트가 실패할 가능성이 높아진다. 
* 초기에 요구 사항을 정확히 분석하면 개발 비용과 시간을 절약할 수 있다.

<h3>기능 요구 사항과 비기능 요구 사항</h3><hr>

* 기능 요구 사항은 소프트웨어가 반드시 수행해야 할 구체적인 동작을 설명한다. 예를 들어, "사용자는 아이디와 비밀번호를 입력해 로그인한다."는 기능 요구 사항이다.
* 비기능 요구 사항은 소프트웨어의 성능, 보안, 유지보수성과 같은 품질 기준을 설명한다. 예를 들어, "시스템은 초당 100개의 요청을 처리할 수 있어야 한다."는 비기능 요구 사항이다.

<h3>요구 사항 수집 기법</h3><hr>

* 인터뷰 : 사용자를 직접 만나 대화를 통해 요구 사항을 수집한다. 상세한 정보를 얻는 데 효과적이다.
* 설문 : 다수의 사용자로부터 정량적인 데이터를 얻기 위해 설문을 활용한다. 응답 결과를 비교하거나 통계적으로 분석하기 좋다.
* 관찰 : 사용자가 실제로 작업을 수행하는 모습을 관찰한다. 이를 통해 숨겨진 요구 사항을 파악할 수 있다.
* 워크숍 : 이해관계자들이 한자리에 모여 토론을 통해 요구 사항을 도출한다. 협력과 합의로 구체적인 요구 사항을 확정할 수 있다.

<h3>요구 사항 명세서 작성</h3><hr>

* 요구 사항 명세서는 요구 사항을 체계적이고 명확하게 문서화한다.
* 작성 시 요구 사항은 반드시 모호하지 않아야 하며, 일관성을 유지해야 한다.
* 기능 요구 사항은 "사용자는 회원가입 시 이메일 주소를 입력해야 한다."처럼 구체적으로 설명한다.
* 비기능 요구 사항은 "시스템은 초당 100건의 요청을 처리해야 한다."와 같이 검증 가능한 형태로 작성한다.


<h3>요구 사항 검증 및 관리</h3><hr>

* 요구 사항 검증은 작성된 요구 사항이 완전하고 일관성이 있는지 확인하는 과정이다. 예를 들어, 리뷰를 통해 검토하거나 테스트 설계를 통해 확인한다.
* 요구 사항 관리는 변경된 요구 사항을 추적하고 관리하는 과정을 설명한다.
  * 변경 요청이 발생하면 반드시 영향 분석을 수행한 후 승인 절차를 거쳐야 한다.
  * 관리 도구로는 JIRA나 Confluence와 같은 소프트웨어를 사용할 수 있다.



소프트웨어 설계
===

1. 소프트웨어 설계의 원칙
2. 모듈화, 추상화, 캡슐화
3. 아키텍처 설계
4. 설계 패턴
5. UML(Unified Modeling Language)


<h3>소프트웨어 설계의 원칙</h3><hr>

* 설계의 단순성: 설계는 단순하고 이해하기 쉬워야 한다. 복잡성을 줄이면 유지보수가 용이하다. 
* 모듈화(Modularity): 시스템을 독립적이고 재사용 가능한 모듈로 분리한다. 이를 통해 개발 속도를 높이고 오류를 국한시킬 수 있다.
* 변경 용이성(Changeability): 요구 사항 변경에 대비하여 설계가 유연해야 한다.
* 응집도(Cohesion)와 결합도(Coupling): 각 모듈의 응집도는 높게 유지하고, 모듈 간 결합도는 낮게 유지해야 한다. 이는 시스템의 유지보수성과 재사용성을 높이는 데 중요하다.
* 재사용성(Reusability): 설계는 다른 프로젝트에서 재사용할 수 있도록 일반화되어야 한다.



<h3>모듈화, 추상화, 캡슐화</h3><hr>

* 모듈화(Modularity): 시스템을 독립적이고 작은 모듈로 나눈다. 각 모듈은 하나의 주요 기능에 집중하며 다른 모듈과 최소한으로 상호작용한다.
  * 예: 로그인, 결제, 주문 관리 모듈 등.
* 추상화(Abstraction): 복잡한 세부 사항을 숨기고 중요한 개념만 드러낸다. 이를 통해 설계의 복잡성을 줄인다.
  * 예: 파일 시스템에서 사용자는 파일 읽기와 쓰기만 알면 되고 내부 구현은 알 필요 없다.
* 캡슐화(Encapsulation): 데이터와 데이터를 처리하는 코드를 하나로 묶어 외부에 노출되지 않도록 한다. 이를 통해 데이터 무결성을 보호하고 코드 재사용성을 높인다.
  * 예: 클래스에서 변수는 private으로 선언하고 접근은 getter/setter로 제한한다.


<h3>아키텍처 설계</h3><hr>

* 소프트웨어 아키텍처는 시스템의 전반적인 구조를 정의하며, 설계의 핵심이다.
* 일반적으로 사용하는 아키텍처 스타일:
  * 레이어드 아키텍처(Layered Architecture): 표현, 비즈니스 로직, 데이터 계층으로 나누어 설계한다.
  * 마이크로서비스 아키텍처(Microservices Architecture): 각 기능을 독립적인 서비스로 구현하여 확장성과 유지보수성을 높인다.
  * 클라이언트-서버 아키텍처(Client-Server Architecture): 클라이언트는 요청을 보내고 서버는 응답을 처리하는 구조다.
  * 이벤트 기반 아키텍처(Event-Driven Architecture): 이벤트를 트리거로 하여 시스템이 동작하는 방식이다.


<h3>설계 패턴</h3><hr>

* 설계 패턴(Design Pattern)은 소프트웨어 설계 문제를 해결하기 위한 재사용 가능한 해결책이다.
* 대표적인 설계 패턴:
  * 생성 패턴(Creational Pattern): 객체 생성 과정을 단순화하고 유연성을 높이는 데 초점.
    * 예: 싱글톤(Singleton), 팩토리 메서드(Factory Method).
  * 구조 패턴(Structural Pattern): 객체 간의 관계를 구성하여 시스템 구조를 단순화.
    * 예: 어댑터(Adapter), 데코레이터(Decorator).
  * 행위 패턴(Behavioral Pattern): 객체 간의 상호작용과 책임 분배를 다룸.
    * 예: 옵저버(Observer), 전략(Strategy).



<h3>UML (Unified Modeling Language)</h3><hr>

* UML은 소프트웨어 설계를 시각적으로 표현하기 위한 표준화된 모델링 언어다.
* UML의 주요 다이어그램:
  * 유스케이스 다이어그램(Use Case Diagram): 시스템의 기능과 사용자 간의 상호작용을 나타낸다.
  * 클래스 다이어그램(Class Diagram): 시스템 내 클래스와 클래스 간의 관계를 표현한다.
  * 시퀀스 다이어그램(Sequence Diagram): 객체 간의 상호작용을 시간 순서에 따라 나타낸다.
  * 활동 다이어그램(Activity Diagram): 시스템의 워크플로우를 표현한다.
* UML은 설계 초기에 소프트웨어의 구조를 이해하고 공유하는 데 중요한 도구로 사용된다.



소프트웨어 구현
===

1. 프로그래밍 원칙과 관례
2. 코드 품질 관리
3. 버전 관리 시스템
4. 코드 리뷰와 협업 도구


<h3>프로그래밍 원칙과 관례</h3><hr>

* 일관성 유지 
  * 코드를 작성할 때 일관된 스타일을 유지해야 한다. 들여쓰기, 변수명, 함수명 등의 규칙을 정하고 이를 준수한다.

* 가독성 향상
  * 코드는 사람이 읽기 쉽게 작성되어야 한다. 명확하고 직관적인 변수명과 함수명을 사용하고, 주석을 통해 코드의 의도를 설명한다.

* DRY 원칙(Don't Repeat Yourself)
  * 중복 코드를 피하고 재사용 가능한 모듈로 코드를 작성한다.

* KISS 원칙(Keep It Simple, Stupid)
  * 복잡한 코드를 지양하고 간단하고 직관적으로 작성한다.

* 에러 처리
  * 예상 가능한 에러 상황에 대한 처리를 철저히 구현한다.



<h3>코드 품질 관리</h3><hr>

* 정적 분석 도구 사용
  * 정적 분석 도구를 사용하여 코드의 품질과 잠재적인 버그를 확인한다. 예: SonarQube, ESLint, Pylint 등.

* 테스트 코드 작성
  * 유닛 테스트, 통합 테스트 등 다양한 테스트를 통해 코드의 정확성과 안정성을 검증한다.

* 리팩토링
  * 동작은 동일하지만 코드의 구조를 개선하는 작업을 주기적으로 진행한다.

* 코드 일관성 점검
  * 코드 스타일 가이드에 따라 작성되었는지 확인하고, 정해진 규칙을 통해 품질을 유지한다.


<h3>버전 관리 시스템</h3><hr>

* 버전 관리 시스템의 필요성
  * 소스 코드를 체계적으로 관리하고 변경 사항을 추적하며, 협업 환경에서 충돌을 방지하기 위해 사용한다.

* 주요 버전 관리 시스템
  * Git: 가장 널리 사용되는 분산 버전 관리 시스템이다.
  * SVN: 중앙 집중형 버전 관리 시스템이다.

* Git의 기본 개념
  * Commit: 변경 사항을 저장한다.
  * Branch: 독립적인 작업 공간을 생성한다.
  * Merge: 다른 브랜치의 변경 사항을 병합한다.
  * Pull Request: 협업 시 코드 변경 사항을 리뷰받기 위해 요청한다.

<h3>코드 리뷰와 협업 도구</h3><hr>

* 코드 리뷰의 중요성
  * 코드 리뷰를 통해 품질을 개선하고 잠재적인 오류를 발견할 수 있다.
  * 동료 개발자와의 피드백 교환은 개인과 팀의 성장에 기여한다.

* 코드 리뷰의 방법
  * 변경된 코드의 의도를 명확히 설명한다.
  * 논리적 오류, 성능 문제, 가독성 저하 요소를 점검한다.
  * 개선 가능한 부분에 대해 구체적인 피드백을 제공한다.

* 협업 도구
  * GitHub: 코드 저장소와 협업을 위한 플랫폼이다.
  * GitLab: GitHub와 유사하지만 자체 서버에서 호스팅이 가능하다.
  * Jira: 작업 계획과 추적을 위한 도구이다.
  * Slack: 팀 간 실시간 커뮤니케이션을 지원하는 도구이다.



소프트웨어 테스트
===

1. 소프트웨어 테스트의 필요성과 목적
2. 테스트 수준
3. 테스트 기법
4. 테스트 자동화 도구

<h3>소프트웨어 테스트의 필요성과 목적</h3><hr>

* 필요성
  * 소프트웨어 테스트는 제품의 품질을 보장하기 위해 필수적이다. 
  * 테스트를 통해 소프트웨어가 요구사항을 만족하는지, 오류가 없는지를 확인한다. 이는 사용자 신뢰를 확보하고, 결함으로 인한 비용을 최소화하는 데 중요하다.

* 목적
  * 소프트웨어 결함 발견
  * 품질 보증 및 안정성 확보
  * 요구사항 충족 여부 검증
  * 유지보수 비용 절감  
  * 사용자 만족도 향상

<h3>테스트 수준</h3><hr>

* 단위 테스트(Unit Test)
  * 소프트웨어의 개별 모듈을 테스트한다. 개발자가 작성하며, 특정 함수나 메서드의 동작을 검증한다.

* 통합 테스트(Integration Test)
  * 모듈 간 상호작용을 확인한다. 통합 시 발생할 수 있는 오류를 조기에 발견한다.

* 시스템 테스트(System Test)
  * 전체 시스템이 요구사항을 충족하는지 검증한다. 사용자의 관점에서 테스트를 수행한다.

* 인수 테스트(Acceptance Test) 
  * 최종 사용자나 고객이 시스템이 요구사항을 충족하는지 확인하는 단계이다.

<h3>테스트 기법</h3><hr>

* 정적 테스트(Static Testing)
  * 실행하지 않고 결함을 검출하는 방법이다. 코드 리뷰, 워크스루, 인스펙션 등이 포함된다.

* 동적 테스트(Dynamic Testing)
  * 실제로 소프트웨어를 실행하여 결함을 검출하는 방법이다.

* 블랙박스 테스트(Black Box Testing)
  * 내부 구조를 모르는 상태에서 입력과 출력만으로 소프트웨어를 테스트한다.

* 화이트박스 테스트(White Box Testing)
  * 내부 코드와 논리를 이해하고 이를 기반으로 테스트를 수행한다.

* 경계값 분석(Boundary Value Analysis)
  * 경계값에서 오류가 발생할 가능성이 높다는 점을 고려하여 테스트를 수행한다.

* 결정 테이블 테스트(Decision Table Testing)
  * 다양한 입력 조건과 그에 따른 결과를 기반으로 테스트한다.



<h3>테스트 자동화 도구</h3><hr>

* 테스트 자동화의 필요성
  * 반복적인 테스트를 효율적으로 수행하고 시간과 비용을 절감하기 위해 테스트 자동화 도구를 사용한다.

* 주요 도구
  * Selenium: 웹 애플리케이션 테스트를 자동화한다.
  * JUnit: Java 기반 단위 테스트를 자동화한다.
  * TestNG: JUnit보다 더 많은 기능을 제공하는 테스트 도구이다.
  * Appium: 모바일 애플리케이션 테스트 자동화에 사용된다.
  * Postman: API 테스트 자동화에 사용된다.





소프트웨어 유지보수
===

1. 유지보수의 정의와 유형
2. 유지보수 프로세스
3. 리팩토링과 코드 품질 개선

<h3>유지보수의 정의와 유형</h3><hr>

* 유지보수의 정의
  * 소프트웨어 유지보수는 개발 후 소프트웨어의 성능을 향상시키거나 문제를 수정하고, 새로운 요구사항에 맞게 기능을 추가하는 과정이다. 이는 소프트웨어의 수명을 연장하고 품질을 유지하는 데 필수적이다.

* 유지보수의 유형
  * 수정적 유지보수(Corrective Maintenance)
    * 소프트웨어의 결함을 수정하여 올바르게 동작하도록 한다.
  * 적응적 유지보수(Adaptive Maintenance)
    * 소프트웨어를 변경된 환경이나 요구사항에 맞게 조정한다.
  * 완전적 유지보수(Perfective Maintenance)
    * 성능을 개선하거나 사용자의 새로운 요구를 반영한다.
  * 예방적 유지보수(Preventive Maintenance)
    * 향후 발생할 가능성이 있는 문제를 사전에 방지한다.
  
<h3>유지보수 프로세스</h3><hr>

* 요구사항 분석
  * 유지보수를 수행하기 위한 변경 요청을 수집하고 분석한다.

* 영향도 평가
  * 변경 사항이 소프트웨어 전체에 미칠 영향을 평가한다.

* 설계 및 구현
  * 요구사항에 따라 수정 및 추가 작업을 수행한다.

* 테스트 및 검증
  * 수정된 소프트웨어가 요구사항을 충족하며 기존 기능에 영향을 미치지 않는지 검증한다.

* 배포 및 문서화
  * 수정된 소프트웨어를 배포하고, 관련 문서를 업데이트한다.

* 피드백 수집
  * 유지보수 결과에 대한 사용자 피드백을 수집하여 품질을 보완한다.


<h3>리팩토링과 코드 품질 개선</h3><hr>

* 리팩토링의 정의
  * 리팩토링은 소프트웨어의 외부 동작을 유지하면서 내부 코드를 개선하는 작업이다. 이는 유지보수를 용이하게 하고 성능을 향상시킨다.

* 리팩토링의 필요성
  * 코드 복잡성 감소
  * 가독성 향상
  * 기술 부채 해결
  * 테스트 용이성 증대

* 주요 리팩토링 기법
  * 코드 정리(Clean Code): 중복 제거, 명확한 변수명 사용
  * 모듈화(Modularization): 코드의 기능별 분리
  * 주석 추가(Commenting): 코드 이해를 돕기 위한 명확한 주석 작성
  * 중복 제거(Deduplication): 동일한 기능의 코드를 통합

* 코드 품질 관리 도구
  * SonarQube: 코드 품질과 보안을 분석하는 도구
  * ESLint: JavaScript 코드의 품질을 검토한다.
  * PMD: Java 코드의 결함을 감지한다.



프로젝트 관리
===

1. 소프트웨어 프로젝트 관리 개념
2. 프로젝트 계획과 일정 관리
3. 자원 관리
4. 리스크 관리
5. 소프트웨어 품질 보증(SQA)

<h3>소프트웨어 프로젝트 관리 개념</h3><hr>

* 소프트웨어 프로젝트 관리의 정의
  * 소프트웨어 프로젝트 관리는 프로젝트 목표를 효과적으로 달성하기 위해 자원, 일정, 품질, 리스크 등을 체계적으로 계획하고 조정하는 과정이다.

* 목적
  * 프로젝트 목표를 명확히 정의하고 달성한다.
  * 일정과 예산을 준수한다.
  * 품질 높은 소프트웨어를 개발한다.

* 주요 활동 
  * 요구사항 관리
  * 일정 및 자원 계획
  * 팀 구성 및 역할 배정
  * 프로젝트 추적 및 통제

<h3>소프트웨어 프로젝트 관리 개념</h3><hr>

* 프로젝트 계획
  * 프로젝트 목표를 정의하고 이를 달성하기 위한 단계를 설계한다.
    * 활동 식별: 프로젝트를 구성하는 주요 작업을 나열한다.
    * 일정 산정: 각 작업의 소요 시간을 예측한다.
    * 우선순위 설정: 중요한 작업을 우선 처리하도록 계획한다.

* 일정 관리
  * 계획된 일정이 지켜지도록 작업을 모니터링하고 조정한다.
    * Gantt Chart: 작업 일정과 상태를 시각화하는 도구.
    * Critical Path Method (CPM): 프로젝트의 최장 경로를 분석하여 일정을 관리한다.
    * Agile 일정 관리: 스프린트를 사용하여 일정 계획과 실행을 반복적으로 수행한다.

<h3>자원 관리</h3><hr>

* 자원 관리의 정의
  * 프로젝트 목표를 달성하기 위해 인적, 물적 자원을 효과적으로 배치하고 활용하는 과정이다.

* 주요 요소
  * 인적 자원: 개발자, 디자이너, QA 등 프로젝트에 필요한 팀원.
  * 물적 자원: 하드웨어, 소프트웨어, 개발 도구 등.
  * 재정 자원: 프로젝트 실행에 필요한 예산.

* 효과적인 자원 관리 기법
  * 작업 분배를 명확히 하여 팀원의 역할을 정의한다.
  * 자원의 부족 또는 초과 사용을 방지하기 위해 정기적으로 점검한다.
  * 팀원 간의 협력을 촉진하고 갈등을 조정한다. 

<h3>리스크 관리</h3><hr>

* 리스크 관리의 정의
  * 프로젝트 실행 과정에서 발생할 수 있는 잠재적인 문제를 식별하고 이를 최소화하거나 제거하는 활동이다.

* 리스크 관리 단계
  * 리스크 식별: 발생 가능성이 있는 리스크를 분석한다.
  * 리스크 평가: 리스크의 영향과 발생 가능성을 평가한다.
  * 리스크 대응 계획 수립: 리스크를 예방하거나 완화하기 위한 전략을 개발한다.
  * 모니터링 및 통제: 리스크 상태를 지속적으로 추적하고 필요시 조정한다.

* 리스크 대응 전략
  * 회피(Avoidance): 리스크 발생 가능성을 제거한다.
  * 완화(Mitigation): 리스크의 영향을 줄인다.
  * 전가(Transfer): 리스크를 다른 팀이나 외부에 이전한다.
  * 수용(Acceptance): 리스크를 인정하고 이를 관리한다.

<h3>소프트웨어 품질 보증(SQA)</h3><hr>

* SQA의 정의
  * 소프트웨어 개발 과정 전반에서 품질을 보장하기 위한 체계적 활동이다.

* 목적
  * 결함을 최소화하고 품질 높은 소프트웨어를 개발한다.
  * 프로젝트 요구사항과 표준을 준수한다.

* 주요 활동
  * 프로세스 품질 관리: 소프트웨어 개발 프로세스의 효율성과 일관성을 보장한다.
  * 테스트 계획 및 실행: 결함을 발견하고 수정한다.
  * 코드 품질 분석: 코드 리뷰와 정적 분석을 통해 품질을 점검한다.

* SQA 도구
  * JIRA: 결함 추적 및 프로젝트 관리 도구.
  * SonarQube: 코드 품질 점검 도구.
  * TestRail: 테스트 관리 도구.


애자일 소프트웨어 개발
===

1. 애자일의 원칙과 가치
2. 스크럼 프레임워크
3. 칸반과 지속적 전달
4. XP(익스트림 프로그래밍)의 실천

<h3>애자일의 원칙과 가치</h3><hr>

* 애자일의 정의
  * 애자일 소프트웨어 개발은 변화하는 요구사항에 유연하게 대응하며, 소프트웨어를 점진적이고 반복적으로 개발하는 방법론이다.

* 애자일 선언문 (Agile Manifesto)
  * 개인과 상호작용을 프로세스와 도구보다 중시한다.
  * 작동하는 소프트웨어를 포괄적인 문서보다 중시한다.
  * 고객과의 협력을 계약 협상보다 중시한다.
  * 변화에 대한 대응을 계획을 따르는 것보다 중시한다.

* 애자일의 12가지 원칙
  * 고객 만족을 최우선으로 하며, 가치를 제공한다.
  * 요구사항 변경을 수용한다.
  * 작동하는 소프트웨어를 자주 제공한다.
  * 개발자와 비즈니스 담당자가 긴밀히 협력한다.
  * 동기 부여된 개인 중심의 프로젝트를 구성한다.
  * 대면 커뮤니케이션을 통한 효율적 전달을 권장한다.
  * 작동하는 소프트웨어가 진척의 주요 척도이다.
  * 지속 가능한 개발 속도를 유지한다.
  * 기술적 우수성과 좋은 설계를 강조한다.
  * 단순함을 추구한다.
  * 자율적인 팀을 구성하여 최고의 설계를 도출한다.
  * 주기적으로 팀이 작업 방식을 점검하고 조정한다.

<h3>스크럼 프레임워크</h3><hr>

* 스크럼의 정의
  * 애자일 철학을 기반으로 한 소프트웨어 개발 프레임워크로, 팀워크, 반복적 개발, 점진적 개선에 중점을 둔다.

* 스크럼 구성 요소
  * 스크럼 팀: 개발팀, 제품 소유자(PO), 스크럼 마스터(SM)로 구성된다.
  * 스프린트: 일반적으로 2~4주 간격으로 설정된 개발 주기.
  * 백로그:
    * 제품 백로그(Product Backlog): 제품 요구사항 목록.
    * 스프린트 백로그(Sprint Backlog): 스프린트 동안 처리할 작업 목록.
  * 데일리 스크럼: 팀원들이 진행 상황과 장애 요소를 공유하는 짧은 회의.
  * 스프린트 회고: 스프린트 종료 후 개선점을 논의하는 미팅.

<h3>칸반과 지속적 전달</h3><hr>

* 칸반의 정의
  * 칸반은 작업 흐름을 시각화하고 병목 현상을 최소화하여 작업 효율을 높이는 애자일 방법론이다.

* 주요 원칙
  * 작업을 시각적으로 표현하여 프로세스 상태를 명확히 한다.
  * 작업 중인 항목의 개수를 제한하여 과부하를 방지한다.
  * 작업 흐름을 지속적으로 모니터링하고 개선한다.

* 칸반 보드 구성 요소
  * 열(Column): 작업의 상태(예: 해야 할 일, 진행 중, 완료).
  * 카드(Card): 작업 항목을 나타내는 카드.

* 지속적 전달 (Continuous Delivery)
  * 소프트웨어 변경 사항을 짧은 주기로 배포 가능 상태로 유지한다.
  * 자동화된 빌드, 테스트, 배포를 통해 품질을 보장한다.

<h3>XP(익스트림 프로그래밍)의 실천</h3><hr>

* XP의 정의
  * XP는 애자일 원칙에 따라 소프트웨어 개발에서 프로그래밍 중심의 실천을 강조하는 방법론이다.

* XP의 주요 실천 방법
  * 짝 프로그래밍 (Pair Programming): 두 명의 개발자가 하나의 컴퓨터에서 협력하여 코드를 작성.
  * 테스트 주도 개발 (TDD): 테스트 케이스를 먼저 작성한 후 코드를 개발.
  * 지속적 통합 (Continuous Integration): 코드 변경 사항을 자주 통합하여 오류를 빠르게 발견.
  * 단순 설계 (Simple Design): 현재 요구사항만 충족하는 간단한 설계 추구.
  * 작동하는 소프트웨어 우선: 문서보다는 실행 가능한 코드를 중시.

* XP의 가치
  * 의사소통
  * 단순성
  * 피드백
  * 용기
  * 존중

소프트웨어 메트릭
===

1. 소프트웨어 메트릭의 개념
2. 코드 복잡도 측정
3. 생산성과 품질 메트릭
4. 메트릭 기반 프로젝트 관리

<h3>소프트웨어 메트릭의 개념</h3><hr>

* 소프트웨어 메트릭의 정의
  * 소프트웨어 메트릭은 소프트웨어의 성능, 품질, 유지보수성 등을 정량적으로 측정하기 위한 지표이다.
  * 이를 통해 개발 프로세스를 평가하고 개선하는 데 활용한다.

* 메트릭의 필요성
  * 소프트웨어 품질 및 효율성 평가.
  * 프로젝트 관리 및 의사결정 지원.
  * 문제 식별 및 예방.

* 종류
  * 프로세스 메트릭: 소프트웨어 개발 및 유지보수 과정의 효율성을 측정.
  * 제품 메트릭: 소프트웨어 산출물(코드, 설계)의 특성을 측정.
  * 프로젝트 메트릭: 프로젝트 관리와 관련된 요소(일정, 비용)를 측정.


<h3>코드 복잡도 측정</h3><hr>

* 코드 복잡도의 정의
  * 코드 복잡도는 소스 코드의 복잡성을 정량적으로 표현한 값으로, 코드의 품질 및 유지보수성을 평가한다.

* 측정 지표
  * 사이클로매틱 복잡도 (Cyclomatic Complexity)
    * 제어 흐름의 복잡성을 측정하는 지표.
    * 계산 방법: M = E - N + 2P (E: 엣지 수, N: 노드 수, P: 제어 흐름 그래프의 연결된 컴포넌트 수).
    * 복잡도가 높을수록 테스트 및 유지보수가 어려움.
  * 라인 수 (Lines of Code, LOC)
    * 코드의 총 라인 수를 측정.
    * 간단하지만 코드 품질과의 직접적인 상관관계는 낮음.
  * 팬인/팬아웃 (Fan-In/Fan-Out)
    * 모듈의 입력과 출력 의존성을 측정하여 모듈 간 결합도를 평가.


<h3>생산성과 품질 메트릭</h3><hr>

* 생산성 메트릭
  * KLOC (천 라인 당 코드)
    * 개발된 코드의 천 라인 단위로 생산성을 측정.
      * 생산성: KLOC / 개발 시간.
  * 기능 점수 (Function Points)
    * 기능 기반으로 소프트웨어의 크기를 측정하고 생산성을 평가.

* 품질 메트릭
  * 결함 밀도 (Defect Density)
    * LOC 또는 KLOC 단위당 발견된 결함 수.
    * 결함 밀도 = 결함 수 / LOC.
  * 고장율 (Failure Rate)
    * 소프트웨어 실행 시간 대비 발생한 결함의 빈도.
  * 유지보수성 (Maintainability)
    * 코드의 수정 용이성을 정량적으로 평가.

<h3>메트릭 기반 프로젝트 관리</h3><hr>

* 메트릭의 활용
  * 프로젝트 진행 상황 추적 및 평가.
    * 리스크 식별 및 대응 전략 수립.
    * 효율적인 자원 배분과 일정 관리.

* 주요 활용 사례
  * 예측 분석: 메트릭 데이터를 통해 프로젝트 성공 가능성을 예측.
  * 성능 모니터링: 개발 속도와 품질을 지속적으로 측정.
  * 프로젝트 상태 보고: 객관적 데이터를 바탕으로 이해 관계자와 소통.

* 도구 및 기술
  * 정적 분석 도구 (예: SonarQube, Coverity).
  * 버전 관리 시스템 데이터 활용 (예: Git metrics).
  * 자동화된 품질 분석 도구.





리스크 관리
===

1. 
2. 
3. 

<h3></h3><hr>

* 


소프트웨어 재사용과 컴포넌트 기반 개발
===

1. 
2. 
3. 

<h3></h3><hr>

* 


소프트웨어 보안
===

1. 
2.
3.
4.
